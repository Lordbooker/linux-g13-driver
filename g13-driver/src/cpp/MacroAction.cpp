#include <string.h>
#include <vector>
#include <iostream>
#include <memory>     // For std::unique_ptr
#include <sstream>    // For std::stringstream, enabling modern C++ string parsing

#include "MacroAction.h"

/**
 * @brief Static thread entry function.
 * @param context A void pointer to the MacroAction instance.
 * @return Always returns nullptr.
 *
 * This function is the entry point for the new thread created to run a macro.
 * It casts the context back to a MacroAction pointer and calls the instance's
 * execution loop.
 */
void* MacroAction::run_macro_thread(void *context) {
    MacroAction* action = static_cast<MacroAction*>(context);
    action->execute_macro_loop();
    return nullptr;
}

/**
 * @brief The main loop for macro execution within its own thread.
 *
 * This loop's logic is corrected to properly handle the repeat settings from the UI.
 * - _repeats == 0: Run the macro sequence once.
 * - _repeats == 1: Repeat the macro sequence while the key is held down.
 * - _repeats > 1: Repeat the macro sequence a fixed number of times.
 */
void MacroAction::execute_macro_loop() {
    _thread_keep_repeating_flag = true;

    // Case: Run Once. The GUI sends _repeats = 0 for this.
    if (_repeats == 0) {
        for (const auto& event : _events) {
            event->execute();
        }
        _is_macro_running = false; // Macro is done
        return; // Exit thread function
    }

    // Case: Repeating macros (_repeats >= 1)
    int current_repeats = 0;
    while (_thread_keep_repeating_flag) {
        // Execute one full sequence of events.
        for (const auto& event : _events) {
            // Check if the thread should terminate, e.g., if key_up was called during a delay.
            if (!_thread_keep_repeating_flag) break;
            event->execute();
        }

        // Check again for termination after the sequence is complete.
        if (!_thread_keep_repeating_flag) break;

        // Handle fixed-repeat macros (a feature not used by the GUI but supported by the driver).
        if (_repeats > 1) {
            current_repeats++;
            if (current_repeats >= _repeats) {
                break; // Stop after N repetitions.
            }
        }
        // If _repeats == 1 (the "repeat while held" mode from the GUI), the loop continues.
        // It will only be stopped when key_up() sets _thread_keep_repeating_flag to false.
    }

    _is_macro_running = false; // Mark macro as finished.
}

/**
 * @brief Parses a single token from a macro sequence string into an Event object.
 * @param token The string token (e.g., "kd.29", "ku.29", "d.100").
 * @return A unique_ptr to the created Event, or nullptr if the token is invalid.
 *
 * This function is updated to parse the format generated by the Java config tool.
 */
std::unique_ptr<MacroAction::Event> MacroAction::tokenToEvent(const std::string& token) {
    if (token.empty()) {
        return nullptr;
    }

    try {
        // Check for "kd." prefix (key down)
        if (token.rfind("kd.", 0) == 0) {
            int keycode = std::stoi(token.substr(3));
            return std::make_unique<KeyDownEvent>(keycode);
        }
        // Check for "ku." prefix (key up)
        if (token.rfind("ku.", 0) == 0) {
            int keycode = std::stoi(token.substr(3));
            return std::make_unique<KeyUpEvent>(keycode);
        }
        // Check for "d." prefix (delay)
        if (token.rfind("d.", 0) == 0) {
            int delay = std::stoi(token.substr(2));
            return std::make_unique<WaitEvent>(delay);
        }
    } catch (const std::invalid_argument& ia) {
        std::cerr << "MacroAction::tokenToEvent: Invalid number in token: " << token << std::endl;
        return nullptr;
    } catch (const std::out_of_range& oor) {
        std::cerr << "MacroAction::tokenToEvent: Number out of range in token: " << token << std::endl;
        return nullptr;
    }

    // Log an error if the token format is unknown.
    std::cerr << "MacroAction::tokenToEvent: Unknown macro token format: " << token << std::endl;
    return nullptr;
}


// --- Constructor / Destructor ---

/**
 * @brief Constructs a MacroAction from a sequence string.
 * @param sequence The comma-delimited string of macro events (e.g., "kd.29,d.100,ku.29").
 *
 * This constructor uses std::stringstream for robustly parsing the comma-separated sequence.
 */
MacroAction::MacroAction(const std::string& sequence)
    : _repeats(0), _repeats_on_press(0), _is_macro_running(false), _thread_keep_repeating_flag(false), _macro_thread_id(0) {

    // Use a stringstream to parse the comma-separated sequence.
    std::stringstream ss(sequence);
    std::string token;

    // Read tokens separated by commas.
    while (std::getline(ss, token, ',')) {
        if (!token.empty()) {
            auto event = tokenToEvent(token);
            if (event) {
                // Move the created event into the events vector.
                _events.push_back(std::move(event));
            }
        }
    }
}

/**
 * @brief Destructor for MacroAction.
 *
 * If a macro thread is still running, it signals the thread to stop and
 * waits for it to terminate cleanly to prevent resource leaks.
 */
MacroAction::~MacroAction() {
    if (_is_macro_running) {
        _thread_keep_repeating_flag = false; // Signal the thread to stop.
        pthread_join(_macro_thread_id, nullptr); // Wait for the thread to finish.
    }
    // _events vector is cleaned up automatically by unique_ptr destructors.
}

// --- Key-Events ---

/**
 * @brief Handles the key-down event for this action.
 *
 * If a macro is not already running, it starts a new thread to execute it.
 * If a macro is running, pressing the key again will signal it to stop.
 */
void MacroAction::key_down() {
    if (isPressed()) {
        if (_is_macro_running) {
            // If the macro is running, pressing the key again stops it (toggle behavior).
            _thread_keep_repeating_flag = false;
            return;
        }

        if (_events.empty()) {
            return; // Nothing to execute.
        }

        _is_macro_running = true;
        // Create a new thread to run the macro, passing 'this' as the context.
        if (pthread_create(&_macro_thread_id, nullptr, &MacroAction::run_macro_thread, this) != 0) {
            // If thread creation fails, log the error and reset the state.
            perror("pthread_create() error");
            _is_macro_running = false;
        }
    }
}

/**
 * @brief Handles the key-up event for this action.
 *
 * If the macro is set to repeat only while held (_repeats == 1), releasing
 * the key will stop the macro execution. This is the core of the "Auto Repeat" feature.
 */
void MacroAction::key_up() {
    if (_repeats == 1) {
       _thread_keep_repeating_flag = false;
    }
}

// --- Getter / Setter ---

int MacroAction::getRepeats() const {
    return _repeats;
}

void MacroAction::setRepeats(int repeats) {
    this->_repeats = repeats;
}